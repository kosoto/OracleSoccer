<HealthCheckItems>
	<Item InternalID="151">AUDIT_TRAIL = os | db | db_extended | xml | xml_extended  results in Oracle collecting instance wide audit trail information, which adds a slight overhead to all database transactions  that might be inadvisable for a production database.  AUDIT_TRAIL = none | false disables all such audit data collection and its overhead.  Prior to Oracle 11g, AUDIT_TRAIL = none was the default.  It is now AUDIT_TRAIL = db, which means to both enable auditing and to store that information within the database.</Item>
	<Item InternalID="152">AUDIT_SYS_OPERATIONS = true enables auditing of operations issued by user SYS and users connecting with SYSDBA or SYSOPER privileges.  Generally speaking most compliance checks are at a minimum for just the database application users.  It may not be necessary to collect audit data for privileged accounts performing database maintenance as opposed to apps working directly with company data.  The default is AUDIT_SYS_OPERATIONS = false.</Item>
	<Item InternalID="153">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="177">Let Oracle set the current CPU_COUNT based upon currently available OS resources since under a virtual machine it's rather easy to add or subtract CPUs.  In fact in some cases CPUs can even be dynamically allocated based upon virtual machine load.  Therefore hard coding the CPU_COUNT is not recommended since the logical number of CPUs can vary.</Item>
	<Item InternalID="102">Let Oracle identify the current CPU_COUNT the OS sees - since CPU multi-core upgrades have become quite common and inexpensive.  Plus database host relocation is also not totally uncommon anymore.  Therefore hard coding the CPU_COUNT is not recommended since the physical number of CPUs can vary.</Item>
	<Item InternalID="103">Many OLTP and data warehousing databases repetitively execute the same commands.  For example a hard-coded screen or report run by one user that is also run by another user will often only vary the bind variable values.  Setting CURSOR_SHARING=similar permits Oracle to share cursors across sessions for such scenarios.  This can radically reduce the amount of hard parsing.  Furthermore it can help to reduce SGA and/or PGA memory usage in some cases.</Item>
	<Item InternalID="104">Setting CURSOR_SPACE_FOR_TIME=true instructs Oracle to favor space for cursors in order to save time.  The database will then tend to "pin" SQL inside the library cache shared pool area, thus making all SQL ineligible for the aging-out process until the cursor for the SQL statement is closed.  Oracle recommends setting CURSOR_SPACE_FOR_TIME=true in any database where SHARED_POOL_SIZE is large enough to simultaneously contain all open cursors.</Item>
	<Item InternalID="105">It used to be that DB_CACHE_SIZE X DB_BLOCK_SIZE determined the total size of the SGA's buffer cache (data).  Oracle now supports having multiple block sizes within a database and for separate dynamic DB_CACHE_SIZE buffer areas within the SGA.  So for best control use only the newer parameters.</Item>
	<Item InternalID="106">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="107">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="100">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="127">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="109">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="110">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="111">Memory is cheap and abundant these days - even on notebooks and desktop PCs.  And although cache hit ratios are no longer stressed as in days past with the emphasis instead more on wait states, memory is still faster than disk IO.  Therefore don't skimp on memory allocations for Oracle.  In some cases this value will have been derived from another setting, so you need to change another parameter to affect this one.  Also note that with the much newer automatic and dynamic memory allocation settings available, this rule may not apply.</Item>
	<Item InternalID="178">Let Oracle set the current DB_WRITER_PROCESSES based upon currently available OS resources since under a virtual machine it's rather easy to add or subtract CPUs.  In fact in some cases CPUs can even be dynamically allocated based upon virtual machine load.  Therefore hard coding the DB_WRITER_PROCESSES is not recommended since the logical number of CPUs can vary.</Item>
	<Item InternalID="186">Oracle Enterprise Manager (OEM) offers several optional, extra cost add-ons that you must be properly licensed for in order to use directly or indirectly (i.e. via TOAD).  Note that these optional add-ons are often automatically installed and enabled in a databases created by Oracle's Database Creation Assistant (DBCA).  That includes the database generated by the Oracle installer - which simply calls DBCA after installing the software.</Item>
	<Item InternalID="187">Oracle Enterprise Manager (OEM) offers several optional, extra cost add-ons that you must be properly licensed for in order to use directly or indirectly (i.e. via TOAD).  Note that these optional add-ons are often automatically installed and enabled in a databases created by Oracle's Database Creation Assistant (DBCA).  That includes the database generated by the Oracle installer - which simply calls DBCA after installing the software.</Item>
	<Item InternalID="188">Oracle Enterprise Manager (OEM) offers several optional, extra cost add-ons that you must be properly licensed for in order to use directly or indirectly (i.e. via TOAD).  Note that these optional add-ons are often automatically installed and enabled in a databases created by Oracle's Database Creation Assistant (DBCA).  That includes the database generated by the Oracle installer - which simply calls DBCA after installing the software.</Item>
	<Item InternalID="93">Often knowing which initialization parameters remain set to their defaults is useful.  You might be interested in knowing which parameters don't match "golden rules" or "best practices" and which parameters' values have changed from one version to another.  For example the parameter DB_FILE_MULTIBLOCK_READ_COUNT default value increased from 16 to 128.  That might be worth knowing.</Item>
	<Item InternalID="94">Often knowing which initialization parameters have been deprecated is important.  When you attempt to start your database with deprecated parameters set, one of two scenarios can happen.  Either the database will start and log a warning in the alert.log file, or the database simply won't open and log an error in the alert.log file.  Both scenarios are best avoided.</Item>
	<Item InternalID="95">The initialization parameter COMPATIBLE defaults to that of the current software installed.  However there are times where you might change this.  For example when initially deploying a new version, you might set COMPATBLE to the earlier version so as to guarantee backward compatibility of your application with that earlier release.  Knowing that this parameter has been set to anything less than the current release is worth knowing as it might prevent you from realizing the benefits offered by newer releases if you forget to unset it.</Item>
	<Item InternalID="96">The initialization parameter OPTIMIZER_FEATURES_ENABLE defaults to that of the current software installed.  However there are times where you might change this.  For example when initially deploying a new version, you might set OPTIMIZER_FEATURES_ENABLE to the earlier version so as to guarantee backward compatibility of your application with that earlier release.  Knowing that this parameter has been set to anything less than the current release is worth knowing as it might prevent you from realizing the benefits offered by newer releases if you forget to unset it.</Item>
	<Item InternalID="97">The OPTIMIZER_INDEX_CACHING parameter defaults to 0.  It can range from 0 to 100, which indicates the percentage of the index blocks the optimizer should assume are in the cache.  Many people feel that with properly defined indexes that this default is too conservative.  With a good index design informing Oracle that a larger percentage are likely to be in the cache will generally result in the optimizer making a better decision about whether to perform an index scan of a full-table.  More specifically setting this parameter to a higher value makes nested loops joins and IN-list iterators look less expensive to the optimizer.</Item>
	<Item InternalID="98">The OPTIMIZER_INDEX_COST_ADJ parameter defaults to 100.  It can range from 0 to 100, which informs the optimizer to evaluate index access paths at the "regular" or same cost as any other access path (e.g. full table scan).  Many people feel that with properly defined indexes that this default is too liberal.  With a good index design informing Oracle that an index scan might be cheaper will generally result in the optimizer more prone to selecting an index access path over a full table scan - and better performance.</Item>
	<Item InternalID="101">For safety (i.e. better fault tolerance) it is advisable to have at least three control files all on separate disks.</Item>
	<Item InternalID="108">If DB_KEEP_CACHE_SIZE &gt; 0 and the database has no objects specified as KEEP, then you may have wasted or underutilized SGA memory allocations.</Item>
	<Item InternalID="112">If any database buffer caches are set as DB_nK_CACHE_SIZE &gt; 0 and the database has no objects specified as using that block size, then you may have wasted or underutilized SGA memory allocations.</Item>
	<Item InternalID="154">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="157">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="8">Relational database tables should generally have a primary key so that you can distinguish one row from another.</Item>
	<Item InternalID="179">Let Oracle set the current PARALLEL_THREADS_PER_CPU based upon currently available OS resources since under a virtual machine it's rather easy to add or subtract CPUs.  In fact in some cases CPUs can even be dynamically allocated based upon virtual machine load.  Therefore hard coding the PARALLEL_THREADS_PER_CPU is not recommended since the logical number of CPUs can vary.</Item>
	<Item InternalID="180">Let Oracle set the current RESOURCE_MANAGER_CPU_ALLOCATION based upon currently available OS resources since under a virtual machine it's rather easy to add or subtract CPUs.  In fact in some cases CPUs can even be dynamically allocated based upon virtual machine load.  Therefore hard coding the RESOURCE_MANAGER_CPU_ALLOCATION is not recommended since the logical number of CPUs can vary.</Item>
	<Item InternalID="181">Not all virtual machine vendors manage VM memory allocations and management the same way.  In fact, the memory management features and capabilities can vary for a single vendor providing multiple solutions (e.g. Oracle has OVM, Virtual Box, etc.).  Furthermore under a virtual machine it's rather easy to add or subtract memory.  In fact in some cases memory can even be dynamically allocated based upon virtual machine load.  Thus forcing the entire SGA to lock within the VM OS could reduce the number of concurrent VMs that a host can run.  Although some vendors (such as VMware) offer something known as a "balloon driver" that seeks to alleviate memory over allocation issues, many believe that it's simply better not to push memory over-allocation.</Item>
	<Item InternalID="182">Not all virtual machine vendors manage VM memory allocations and management the same way.  In fact, the memory management features and capabilities can vary for a single vendor providing multiple solutions (e.g. Oracle has OVM, Virtual Box, etc.).  Furthermore under a virtual machine it's rather easy to add or subtract memory.  In fact in some cases memory can even be dynamically allocated based upon virtual machine load.  Thus forcing the entire SGA to pre-load within the VM OS could reduce the number of concurrent VMs that a host can run.  Although some vendors (such as VMware) offer something known as a "balloon driver" that seeks to alleviate memory over allocation issues, many believe that it's simply better not to push memory over-allocation.</Item>
	<Item InternalID="99">Newer versions of Oracle offer much more automated memory management initialization parameter settings.  Under Oracle 10g these parameters include SGA_MAX_SIZE,  SGA_TARGET and PGA_AGGREGATE_TARGET.  Under Oracle 11g these parameters include MEMORY_TARGET and MEMORY_MAX_TARGET.  If you use the 11g parameters you should not set the 10g ones.  If you use the 10g parameters you should not set individual memory management parameters such as DB_CACHE_SIZE, SHARED_POOL_SIZE, LARGE_POOL_SIZE, JAVA_POOL_SIZE, STREAMS_POOL_SIZE, WORKAREA_SIZE_POLICY and all the *_AREA_SIZE parameters.</Item>
	<Item InternalID="113">If any tablespaces have their default block size set to nK and there are no database buffer caches set with DB_nK_CACHE_SIZE &gt; 0 then your general database buffer cache may have to handle multiple block sizes which can lead to inefficient memory utilization - and gaps.</Item>
	<Item InternalID="39">The SYSTEM tablespace should be reserved for catalog use only or at least primarily.  When you permit users to create and drop temporary objects with the SYSTEM tablespace this only helps to both fragment that space and/or create gaps within the space.  Both of which can slow true data dictionary operations and hence your entire database.  Simply do not do this.</Item>
	<Item InternalID="40">The SYSTEM tablespace should be reserved for catalog use only or at least primarily.  When you permit users to create and drop persistent objects with the SYSTEM tablespace this only helps to both fragment that space and/or create gaps within the space.  Both of which can slow true data dictionary operations and hence your entire database.  Simply do not do this.</Item>
	<Item InternalID="55">When you create a user and specify their default temporary tablespace, Oracle verifies that tablespace exists.  But if that tablespace is later dropped, then the user definition ends up referencing a non-existent tablespace.</Item>
	<Item InternalID="56">When you create a user and specify their default persistent tablespace, Oracle verifies that tablespace exists.  But if that tablespace is later dropped, then the user definition ends up referencing a non-existent tablespace.</Item>
	<Item InternalID="32">Dictionary managed tablespaces (i.e. those with rows in DBA_DMT_FREE_SPACE) with a high degree of fragmentation can often result in performance degradation.  Locally managed tablespaces are much less prone to this type of problem.</Item>
	<Item InternalID="33">If your tablespace is approaching full and you do not have auto-extend specified for its datafiles then you will get the nasty "cannot allocate extent" error.  Note too that even with auto-extend specified some operating systems have file systems with file size limits that limit the auto-extend capability.  Thus is but one test needed to make sure users never encounter the "cannot allocate extent" error.</Item>
	<Item InternalID="20">If your tablespace is approaching full and you do not have auto-extend specified for its datafiles then you will get the nasty "cannot allocate extent" error.  Note too that even with auto-extend specified some operating systems have file systems with file size limits that limit the auto-extend capability.  Thus is but one test needed to make sure users never encounter the "cannot allocate extent" error.</Item>
	<Item InternalID="84">Locally managed tablespaces are now the default and recommended to be used by Oracle for all your tablespaces.  As you migrate from versions &lt;= 8.0 to &gt;= 8i, you should make sure to convert to using locally managed tablespaces.</Item>
	<Item InternalID="114">The days of smaller block sizes being more efficient are long since over.  In most situations a block size of 8K is not unreasonable.  The only exception is RAC environments - where there are still scenarios where a smaller block size (e.g. 4K) is still preferable.</Item>
	<Item InternalID="115">Oracle increased the default for MULTI_BLOCK_READ_COUNT from 16 to 128.  That setting is good for many productions environments, but for smaller deployments (e.g. dev &amp; test) the lesser hardware may benefit from a smaller size.  In addition, certain disk storage systems with cache might benefit from less aggressive read ahead.</Item>
	<Item InternalID="116">In almost all cases database performance will benefit from DISK_ASYNCH_IO = true.  While this is the default for some platforms, this parameter is so important that it's not worth leaving up to chance.</Item>
	<Item InternalID="117">These three parameters provide duplicate methods for attaining similar performance results.  Basically there are two universally recommended scenarios.  First, if you set DISK_ASYNCH_IO to false, then you should also set DBWR_IO_SLAVES to a value other than its default of zero in order to simulate asynchronous I/O.  Second, if you set DISK_ASYNCH_IO to true, then you should also set DBWR_IO_SLAVES to zero (only need one way to affect asynchronous I/O).  Also note that DBWR_IO_SLAVES is relevant only on systems with only one database writer process.</Item>
	<Item InternalID="118">This parameter is calculated based upon other parameter settings, often in a very complex manner with good reasons by Oracle.  You should treat the Oracle calculation as a minimum setting and not choose something that is less than that floor.</Item>
	<Item InternalID="183">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="184">In a production environment you generally should consider some method of controlling resource allocation and usage.  This can often especially be true when you are in a virtual environment where resources are typically much closer to tolerance levels (i.e. less slack since less over capacity).</Item>
	<Item InternalID="185">In a production environment you generally should consider some method of controlling resource allocation and usage.  This can often especially be true when you are in a virtual environment where resources are typically much closer to tolerance levels (i.e. less slack since less over capacity).</Item>
	<Item InternalID="159">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="119">This setting controls whether to use direct I/O and/or asynchronous I/O against file system based database files.  SETALL simply instructs Oracle to attempt to use both mechanisms.</Item>
	<Item InternalID="167">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="121">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="128">In many cases, even for non-data warehouses, allowing the Oracle optimizer consider performing a cost-based star query transformation can lead to a better explain plan.</Item>
	<Item InternalID="123">In many cases, even for non-data warehouses, allowing the Oracle optimizer consider performing a cost-based query rewrite from a base table to its summarized materialized views can lead to a better explain plan.</Item>
	<Item InternalID="129">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="130">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="131">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="132">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="163">For a production system where performance is generally more important than debugging  (except when a problem occurs), then setting this initialization parameter at the database level will result in less general overhead.  You can always alter a session to enable this for specific needs.</Item>
	<Item InternalID="124">Disable this parameter unless you specifically want to take advantage of the recycle bin, otherwise objects that are dropped will still consume space unless the PURGE option is specified on DROP commands.</Item>
	<Item InternalID="150">The Oracle Enterprise Manager (OEM) management packs (e.g diagnostics and tuning) are optional and must be specifically licensed.  However the Database Configuration Assistant (DBCA) creates databases with AWR, ADDM and the PL/SQL packages required to use the optional management packs enabled.  Prior to Oracle 11gR2 the DBA had to disable these optional features manually, there were several ways to accomplish this.  This parameter simplifies that process.</Item>
	<Item InternalID="51">When using the database to store audit data the DBA should move all the audit tables from the SYSTEM tablespace.</Item>
	<Item InternalID="86">In the past this audit table sequence had a cache setting too small to support a high rate of concurrent logins.  The common recommendation was to increase the value to &gt;= 1000.</Item>
	<Item InternalID="45">Knowing which database links are inactive or inaccessible can be very informative when attempting to avoid and/or debug numerous problems.</Item>
	<Item InternalID="43">Oracle recommends at least three redo log groups and two members per group for redundancy (and thus availability).</Item>
	<Item InternalID="85">AWR snapshots consume resources, thus do not schedule them too frequently.  Also the default retention period is far too short for meaningful use, so it should be increased.</Item>
	<Item InternalID="126">Many applications call the same SQL statements during a typical session, thus having at least a 20 cursors cached can reduce parse calls and cursor opens.</Item>
	<Item InternalID="122">It is important to set the value of OPEN_CURSORS high enough to prevent your application from running out of open cursors.  The number will vary from one application to another.  Assuming that a session does not open the number of cursors specified by OPEN_CURSORS, there is no added overhead to setting this value higher than actually needed.</Item>
	<Item InternalID="125">REMOTE_LOGIN_PASSWORDFILE specifies whether Oracle checks for a password file.  When it's set to NONE then Oracle ignores any password file, therefore privileged users must be authenticated by the operating system.  EXCLUSIVE is supported for backward compatibility.  It now has the same behavior as the value SHARED.</Item>
	<Item InternalID="120">When not specifically setting the redo log checkpoint timeout it's recommended to use the advisory utility that allows you to specify your optimal mean time to recovery (MTTR) recovery interval so that it can suggest the optimal redo log size.</Item>
	<Item InternalID="155">PLSQL_OPTIMIZE_LEVEL specifies the optimization level that will be used to compile PL/SQL library units.  The higher the setting of this parameter, the more effort the compiler makes to optimize PL/SQL library units.</Item>
	<Item InternalID="156">PLSQL_CODE_TYPE specifies the compilation mode for PL/SQL library units.  NATIVE means that PL/SQL library units (with the possible exception of top-level anonymous PL/SQL blocks) will be compiled to native (machine) code.  Such modules will be executed natively without incurring any interpreter overhead.</Item>
	<Item InternalID="158">PLSQL_COMPILER_FLAGS specifies a list of flags for the PL/SQL compiler as a comma-separated list of strings.  NATIVE means that PL/SQL library units (with the possible exception of top-level anonymous PL/SQL blocks) will be compiled to native (machine) code.  Such modules will be executed natively without incurring any interpreter overhead.  NON_DEBUG means that PL/SQL library units will be compiled for normal execution.</Item>
	<Item InternalID="57">Relational database tables should generally have at least one unique key and/or index so that you can distinguish one row from another.</Item>
	<Item InternalID="9">Indexes add overhead to all INSERT, UPDATE and DELETE commands.  Thus you should minimize the number of indexes for any given tables to those actually needed for data accuracy and/or query performance.</Item>
	<Item InternalID="46">The error ORA-0600 is a generic catch-all error for those errors so new as not yet to have their own assigned number.  In most cases an ORA-0600 error requires a call to Oracle tech support as this is usually a problem or even a bug with the database.  In most cases the application causing the error is merely exposing an Oracle problem.</Item>
	<Item InternalID="59">Relational database tables should generally narrow and tall.  That means tables should have few columns but many rows.  The idea is to use normalization techniques to keep all the tables well designed.  The exception being data warehouses - where dimension tables often become quite wide (i.e. have many columns).</Item>
	<Item InternalID="60">Indexes add overhead to all INSERT, UPDATE and DELETE commands.  Thus you should minimize the size of indexes (i.e. number of columns) for any given tables to only those columns actually needed for data accuracy and/or query performance.</Item>
	<Item InternalID="61">The LOG and RAW data types have been replaced by CLOB and BLOB data types.  Oracle recommends no longer using the old data types.</Item>
	<Item InternalID="62">It may be beneficial to know when you have global indexes (i.e. those whose partitioning strategy does not match the table's).  There are times where global indexes are preferable.  But in geenral local indexes (i.e. those whose partitioning strategy matches the table's) are the norm.</Item>
	<Item InternalID="63">When a table's row size is larger than the database or tablespace's block size then each row requires two IOs.  You may need to either increase the database block size (a reorganization exercise) or moving the table to a tablespace with a larger block size (a relocation).</Item>
	<Item InternalID="54">Given the INSERT, UPDATE and DELETE overhead costs of indexes one needs to design all indexes without overlapping indexes or duplication of effect.  Since the optimizer can use only one index for a given condition, design indexes such that they can handle the widest range of scenarios.</Item>
	<Item InternalID="58">Even though newer versions of Oracle can maintain primary and unique key constraints using non unique indexes, the DBA may want to be aware of these.</Item>
	<Item InternalID="31">When you join a parent table (using PK) and a child table (using FK) the performance will suffer when the data types and/or lengths are not identical.  Although it's essentially a relational design mistake to allow PKs and FKs not to match - it will work.  But the optimizer will need to add steps to the explain plan to perform implicit data type conversions - which means indexes may not be used.</Item>
	<Item InternalID="53">When the child table does not have an index on a FK, then certain DML operations on that child table will require a lock at some level on the parent table which can radically decrease perfmance.  See the Oracle concepts manual for a complete explanation: Data Integrity chapter, section regarding Concurrency Control, Indexes, and Foreign Keys.</Item>
	<Item InternalID="64">Contrary to popular belief, there is no such thing as a partial FK.  By definition the FK of a child table has to point to a row that exists in the parent or be null.  That means the entire key - and not just portions.  When you create a FK that has both mandatory and optional columns, then the database will not enforce that constraint when some columns are there and others are null.  See the Oracle concepts manual for a complete explanation: Data Integrity chapter, section regarding Nulls and Foreign Keys.</Item>
	<Item InternalID="65">By definition a unique key should have been a candidate primary key that was not chosen as the main or primary key.  As primary keys don't permit optional columns - then neither do the candidate unique keys not chosen as the primary.  See the Oracle concepts manual for a complete explanation: Data Integrity chapter, section regarding Combine UNIQUE Key and NOT NULL Integrity Constraints.</Item>
	<Item InternalID="38">When you define tables and/or columns using mixed case and/or spaces, then all references to these items in application must quote those references.  This is such a pain that it's generally to be avoided.  The only exceptions are third party applications that were built this way and/or databases moved from another platform such as MS SQL Server where mixed case names are more common.  In those cases you may be stuck with mixed case.</Item>
	<Item InternalID="160">CLIENT_RESULT_CACHE_LAG specifies the maximum time (in milliseconds) since the last round trip to the server, before which the OCI client query execute makes a round trip to get any database changes related to the queries cached on the client.  Setting this value too high can result in using stale data.</Item>
	<Item InternalID="161">CLIENT_RESULT_CACHE_SIZE specifies the maximum size of the client per-process result set cache (in bytes).  All OCI client processes inherit this maximum size.  Setting a nonzero value enables the client query cache feature.  This can be overridden by the client configuration parameter OCI_RESULT_CACHE_MAX_SIZE.  Since memory is cheap and plentiful on most client machines these days set the cache to at least 4 MB.</Item>
	<Item InternalID="162">DB_ULTRA_SAFE sets the default values for other parameters that control protection levels.  Better safe than sorry - so do not set to OFF.</Item>
	<Item InternalID="164">JAVA_JIT_ENABLED enables or disables the Just-in-Time (JIT) compiler for the Oracle Java Virtual Machine (OracleJVM) environment.  Since most application developers prefer to use the JVM outside the database, there's often no need to use Oracle's.</Item>
	<Item InternalID="165">JAVA_POOL_SIZE specifies (in bytes) the size of the Java pool, from which the Java memory manager allocates most Java state during runtime execution.  Since most application developers prefer to use the JVM outside the database, there's often no need to use Oracle's.</Item>
	<Item InternalID="166">Java session space is the memory that holds Java state from one database call to another.  Since most application developers prefer to use the JVM outside the database, there's often no need to use Oracle's.</Item>
	<Item InternalID="168">OPTIMIZER_USE_INVISIBLE_INDEXES enables or disables the use of invisible indexes.  FALSE means that invisible indexes will not be considered by the optimizer, but will still be maintained by DML operations.  If the indexes are truly invisible then the optimizer should generally not consider them.</Item>
	<Item InternalID="169">Disable this parameter unless you specifically want to take advantage of the recycle bin, otherwise objects that are dropped will still consume space unless the PURGE option is specified on DROP commands.</Item>
	<Item InternalID="170">RESULT_CACHE_MAX_RESULT specifies the percentage of RESULT_CACHE_MAX_SIZE that any single result can use.  If using this feature advisable not to set it below the default value.</Item>
	<Item InternalID="171">RESULT_CACHE_MODE specifies when a ResultCache operator is spliced into a query's execution plan.  FORCE means that the ResultCache operator is added to the root of all SELECT statements (provided that it is valid to do so).  This may be too wide a setting, it might be better to use use hints for those cases where it makes sense.</Item>
	<Item InternalID="172">RESULT_CACHE_REMOTE_EXPIRATION specifies the number of minutes that a result using a remote object is allowed to remain valid.  Setting this parameter to 0 implies that results using remote objects should not be cached.  Setting this parameter to a nonzero value can produce stale answers (for example, if the remote table used by a result is modified at the remote database).</Item>
	<Item InternalID="143">Oracle recommends at least three redo log groups and two members per group for redundancy (and thus availability).</Item>
	<Item InternalID="88"/>
	<Item InternalID="49"/>
	<Item InternalID="48"/>
	<Item InternalID="47"/>
	<Item InternalID="5"/>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="151">AUDIT_TRAIL = os | db | db_extended | xml | xml_extended 将导致 Oracle 收集实例范围内的审计追踪信息，从而会略微增加所有数据库事务的开销，而对于生产数据库则不宜采用此设置。  AUDIT_TRAIL = none | false 将禁用所有此类审计数据收集和其开销。  对于低于 Oracle 11g 的版本，AUDIT_TRAIL = none 为默认值。  现在为 AUDIT_TRAIL = db，这意味着启用审计且在数据库中存储该信息。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="152">AUDIT_SYS_OPERATIONS = true 将启用审计 SYS 用户及与 SYSDBA 或 SYSOPER 权限关联的用户发出的操作。  一般而言，大多数符合性检查至少仅适用于数据库应用程序用户。  与直接使用公司数据的应用程序相反，可能没有必要收集执行数据库维护的特权帐户的审计数据。  默认值为 AUDIT_SYS_OPERATIONS = false。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="153">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="177">可让 Oracle 根据当前可用的 OS 资源设置当前 CPU_COUNT，因为在虚拟机中增加或减少 CPU 相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配 CPU。  因此，建议不要对 CPU_COUNT 进行硬编码，因为逻辑 CPU 的数量可能会发生变化。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="102">可让 Oracle 确定 OS 将查看的当前 CPU_COUNT - 因为 CPU 多核升级已相当常见且成本不高。  另外，数据库主机重定位也不再罕见。  因此，建议不要对 CPU_COUNT 进行硬编码，因为物理 CPU 的数量可能会发生变化。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="103">许多 OLTP 和数据仓库数据库重复执行相同的命令。  例如，由两个用户同时运行的硬编码屏幕或报告通常只会改变绑定变量值。  针对此类场景设置 CURSOR_SHARING=similar 将允许 Oracle 在会话之间共享游标。  此操作可以从根本上减少硬分析的数量。  此外，在某些情况下，此操作还有助于减少 SGA 和/或 PGA 内存使用率。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="104">设置 CURSOR_SPACE_FOR_TIME=true 将指示 Oracle 优先为游标提供空间以便节省时间。  然后，数据库将易于在库缓存共享池区域中“固定”SQL，因此所有 SQL 无法执行老化进程，直到 SQL 语句的游标关闭。  在 SHARED_POOL_SIZE 足够大可同时容纳所有打开游标的任何数据库中，Oracle 建议设置 CURSOR_SPACE_FOR_TIME=true。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="105">过去，DB_CACHE_SIZE X DB_BLOCK_SIZE 决定 SGA Buffer Cache（数据）的总大小。  现在，Oracle 支持在一个数据库中具有多个块大小且支持 SGA 内单独的动态 DB_CACHE_SIZE 缓冲区区域。  因此，为实现最佳控制，请仅使用更新的参数。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="106">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="107">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="100">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="127">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="109">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="110">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="111">如今，内存价廉易得 - 甚至在笔记本电脑和台式机上亦如此。尽管不再象过去一样强调缓存命中率且更多地强调等待状态，内存仍比磁盘 IO 的速度更快。  因此，请勿忽略 Oracle 的内存分配。  在某些情况下，此值将派生自其他设置，因此您需要更改另一个参数以影响此值。  另请注意，随着更新的自动和动态内存分配设置可用，此规则可能不适用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="178">可让 Oracle 根据当前可用的 OS 资源设置当前 DB_WRITER_PROCESSES，因为在虚拟机中增加或减少 CPU 相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配 CPU。  因此，建议不要对 DB_WRITER_PROCESSES 进行硬编码，因为逻辑 CPU 的数量可能会发生变化。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="186">Oracle Enterprise Manager (OEM) 提供多个可选且需额外费用的扩展，用户必须妥善取得授权才能直接或间接（即通过 TOAD）使用有关扩展。  请注意，这些可选扩展通常会在使用 Oracle Database Creation Assistant (DBCA) 创建的数据库中自动安装和启用。  其中包括 Oracle installer 生成的数据库 - 该数据库只会在安装软件后调用 DBCA。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="187">Oracle Enterprise Manager (OEM) 提供多个可选且需额外费用的扩展，用户必须妥善取得授权才能直接或间接（即通过 TOAD）使用有关扩展。  请注意，这些可选扩展通常会在使用 Oracle Database Creation Assistant (DBCA) 创建的数据库中自动安装和启用。  其中包括 Oracle installer 生成的数据库 - 该数据库只会在安装软件后调用 DBCA。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="188">Oracle Enterprise Manager (OEM) 提供多个可选且需额外费用的扩展，用户必须妥善取得授权才能直接或间接（即通过 TOAD）使用有关扩展。  请注意，这些可选扩展通常会在使用 Oracle Database Creation Assistant (DBCA) 创建的数据库中自动安装和启用。  其中包括 Oracle installer 生成的数据库 - 该数据库只会在安装软件后调用 DBCA。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="93">通常，了解始终设置为其默认值的初始化参数非常有用。  您可能想要了解不符合“黄金规则”或“最佳实践”的参数，以及其值已从一个版本更改为另一个版本的参数。  例如，参数 DB_FILE_MULTIBLOCK_READ_COUNT 的默认值由 16 增加至 128。您可能需要了解该情况。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="94">通常，需要了解已弃用的初始化参数。  如果您尝试使用已弃用的参数集启动数据库，则可能出现两种情况之一。  数据库将启动并在 alert.log 文件中记录一条警告，或数据库不会打开并在 alert.log 文件中记录一个错误。  最好避免出现上述两种情况。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="95">初始化参数 COMPATIBLE 默认为已安装的当前软件的该值。  但是，有时可以更改此值。  例如，初始部署新版本时，您可能会将 COMPATBLE 设置为早期版本，以便确保应用程序与早期版本的向后兼容性。  了解此参数已设置为低于当前版本的值非常重要，因为如果忘记设置此参数，您可能无法了解更新版本提供的优势。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="96">初始化参数 OPTIMIZER_FEATURES_ENABLE 默认为已安装的当前软件的该值。  但是，有时可以更改此值。  例如，初始部署新版本时，您可能会将 OPTIMIZER_FEATURES_ENABLE 设置为早期版本，以便确保应用程序与早期版本的向后兼容性。  了解此参数已设置为低于当前版本的值非常重要，因为如果忘记设置此参数，您可能无法了解更新版本提供的优势。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="97">OPTIMIZER_INDEX_CACHING 参数默认为 0。该值可以介于 0 至 100 之间，表示缓存中优化器应使用的索引块的百分比。  许多人认为应适当定义索引，此默认值过于保守。  良好的索引设计可通知 Oracle 较大的百分比可能位于缓存中，这通常会让优化器对于是否执行全表索引扫描做出更好的决定。  更具体地说，将此参数设置为较高的值将使嵌套循环联接和 IN 列表迭代器对于优化器的开销较低。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="98">OPTIMIZER_INDEX_COST_ADJ 参数默认为 100。该值可以介于 0 至 100 之间，用于通知优化器以“常规”或与任何其他访问路径（如全表扫描）相同的成本评估索引访问路径。  许多人认为应适当定义索引，此默认值过于自由。  良好的索引设计可通知 Oracle 索引扫描的成本可能更低，这通常会导致优化器在全表扫描时更容易选择索引访问路径，且性能更佳。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="101">为确保安全（即较好的容错性），建议在单独磁盘上至少有三个控制文件。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="108">如果 DB_KEEP_CACHE_SIZE &gt; 0 且数据库未指定对象作为 KEEP，则可能会浪费或未充分利用 SGA 内存分配。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="112">如果任何数据库 Buffer Cache 设置为 DB_nK_CACHE_SIZE &gt; 0 且数据库未指定对象使用该块大小，则可能会浪费或未充分利用 SGA 内存分配。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="154">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="157">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="8">关系数据库表通常具有主键，以便可以将一行与另一个区分开来。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="179">可让 Oracle 根据当前可用的 OS 资源设置当前 PARALLEL_THREADS_PER_CPU，因为在虚拟机中增加或减少 CPU 相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配 CPU。  因此，建议不要对 PARALLEL_THREADS_PER_CPU 进行硬编码，因为逻辑 CPU 的数量可能会发生变化。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="180">可让 Oracle 根据当前可用的 OS 资源设置当前 RESOURCE_MANAGER_CPU_ALLOCATION，因为在虚拟机中增加或减少 CPU 相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配 CPU。  因此，建议不要对 RESOURCE_MANAGER_CPU_ALLOCATION 进行硬编码，因为逻辑 CPU 的数量可能会发生变化。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="181">并非所有虚拟机供应商都会以相同的方式管理 VM 内存分配和管理。  实际上，内存管理特性和功能对于提供多种解决方案的供应商有所不同（例如，Oracle 提供 OVM、Virtual Box 等）。  此外，在虚拟机中增加或减少内存相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配内存。  因此，在 VM OS 中强制锁定整个 SGA 可能会减少主机可运行的并发虚拟机数量。  尽管一些供应商（如 VMware）提供“气球驱动程序 (balloon driver)”以缓解内存分配问题，但许多人认为最好不要使内存过度分配。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="182">并非所有虚拟机供应商都会以相同的方式管理 VM 内存分配和管理。  实际上，内存管理特性和功能对于提供多种解决方案的供应商有所不同（例如，Oracle 提供 OVM、Virtual Box 等）。  此外，在虚拟机中增加或减少内存相当容易。  实际上，在某些情况下，甚至可以根据虚拟机负载动态分配内存。  因此，在 VM OS 中强制预加载整个 SGA 可能会减少主机可运行的并发虚拟机数量。  尽管一些供应商（如 VMware）提供“气球驱动程序 (balloon driver)”以缓解内存分配问题，但许多人认为最好不要使内存过度分配。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="99">更新版本的 Oracle 提供更加自动化的内存管理初始化参数设置。  在 Oracle 10g 中，这些参数包括 SGA_MAX_SIZE、SGA_TARGET 和 PGA_AGGREGATE_TARGET。  在 Oracle 11g 中，这些参数包括 MEMORY_TARGET 和 MEMORY_MAX_TARGET。  如果您使用 11g 参数，则不得设置 10g 参数。  如果您使用 10g 参数，则不得设置单个内存管理参数，如 DB_CACHE_SIZE、SHARED_POOL_SIZE、LARGE_POOL_SIZE、JAVA_POOL_SIZE、STREAMS_POOL_SIZE、WORKAREA_SIZE_POLICY 及所有 *_AREA_SIZE 参数。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="113">如果任何表空间将其默认块大小设置为 nK 且任何数据库 Buffer Cache 未设置为 DB_nK_CACHE_SIZE &gt; 0，则常规数据库 Buffer Cache 可能必须处理多个块大小，从而可能导致内存利用效率低下 - 以及缺口。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="39">应至少主要保留 SYSTEM 表空间或保留其仅供目录使用。  如果您允许用户创建和删除具有 SYSTEM 表空间的临时对象，则仅会拆分该空间和/或在空间内创建间隙。  上述两种情况可能会减慢实际数据字典操作的速度，从而使整个数据库的速度变慢。  请勿执行此操作。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="40">应至少主要保留 SYSTEM 表空间或保留其仅供目录使用。  如果您允许用户创建和删除具有 SYSTEM 表空间的永久对象，则仅会拆分该空间和/或在空间内创建间隙。  上述两种情况可能会减慢实际数据字典操作的速度，从而使整个数据库的速度变慢。  请勿执行此操作。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="55">当您创建用户并指定其默认临时表空间时，Oracle 将验证该表空间是否存在。  但是，如果稍后删除该表空间，则用户定义将停止引用不存在的表空间。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="56">当您创建用户并指定其默认永久表空间时，Oracle 将验证该表空间是否存在。  但是，如果稍后删除该表空间，则用户定义将停止引用不存在的表空间。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="32">碎片化程度较高的 Dictionary Managed 表空间（即在 DBA_DMT_FREE_SPACE 中包含行的表空间）通常可能会导致性能下降。  Locally Managed 表空间出现此类问题的几率更小。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="33">如果表空间接近饱和且未针对其数据文件指定自动扩展，则将收到“无法分配区”的严重错误。  另请注意，即使指定了自动扩展，一些操作系统仍会包含具有文件大小限制的文件系统，从而会限制自动扩展功能。  因此，只需一次测试，即可确保用户不会再遇到“无法分配区”的错误。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="20">如果表空间接近饱和且未针对其数据文件指定自动扩展，则将收到“无法分配区”的严重错误。  另请注意，即使指定了自动扩展，一些操作系统仍会包含具有文件大小限制的文件系统，从而会限制自动扩展功能。  因此，只需一次测试，即可确保用户不会再遇到“无法分配区”的错误。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="84">Locally Managed 表空间现在为默认值，且 Oracle 建议将其用于所有表空间。  在将 &lt;=8.0 的版本迁移到 &gt;= 8i 的版本时，应确保转换为使用 Locally Managed 表空间。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="114">块大小越小则越有效率的日子早已过去。  在大多数情况下，块大小为 8K 较为合理。  唯一的例外是 RAC 环境 - 仍存在较小的块大小（如 4K）更合适的情况。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="115">Oracle 已将 MULTI_BLOCK_READ_COUNT 的默认值从 16 增加至 128。该设置适合许多生产环境，但对于小型部署（如设备测试），较少的硬件会从较小的大小中受益。  此外，具有缓存的某些磁盘存储系统可能会得益于较缓慢地预读。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="116">在几乎所有情况下，DISK_ASYNCH_IO = true 将提高数据库性能。  尽管此设置是部分平台的默认设置，但此参数如此重要，因此不能任其自然。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="117">上述三个参数均提供完全相同的方法以实现类似的性能结果。  基本上，有两种普遍建议的场景。  首先，如果将 DISK_ASYNCH_IO 设置为 false，则还应将 DBWR_IO_SLAVES 设置为其默认值零以外的值，以便模拟异步 I/O。其次，如果将 DISK_ASYNCH_IO 设置为 true，则还应将 DBWR_IO_SLAVES 设置为零（仅需要一种方法即可影响异步 I/O）。  另请注意，DBWR_IO_SLAVES 仅在系统中与一个数据库编写器进程有关。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="118">Oracle 通常有充分的理由以非常复杂的方式依据其他参数设置计算此参数。  您应将 Oracle 计算视为最小设置，且不得选择低于该下限的值。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="183">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="184">在生产环境中，您通常应考虑控制资源分配和使用的一些方法。  当您位于资源通常已接近容差级别（即因更少的过载而更少的时差）的虚拟环境中时尤为如此。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="185">在生产环境中，您通常应考虑控制资源分配和使用的一些方法。  当您位于资源通常已接近容差级别（即因更少的过载而更少的时差）的虚拟环境中时尤为如此。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="159">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="119">此设置可控制是否对基于文件系统的数据库文件使用直接 I/O 和/或异步 I/O。  SETALL 仅指示 Oracle 尝试使用两种机制。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="167">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="121">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="128">在许多情况下，即使对于非数据仓库，允许 Oracle 优化器考虑执行基于成本的星型查询转换可能会导致更好的解释计划。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="123">在许多情况下，即使对于非数据仓库，允许 Oracle 优化器考虑从基表到其汇总的实体化视图执行基于成本的 Query Rewrite 可能会导致更好的解释计划。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="129">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="130">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="131">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="132">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="163">对于性能通常比调试更重要（出现问题时除外）的生产系统，在数据库级别设置此初始化参数将减少常规开销。  您可以始终更改会话以启用此设置，从而满足特定需求。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="124">禁用此参数，除非您特别想要利用回收站，否则删除的对象仍会占用空间，除非在 DROP 命令中已指定 PURGE 选项。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="150">Oracle Enterprise Manager (OEM) 管理包（如诊断和调优）为可选，且必须特别地取得授权。  但是，Database Configuration Assistant (DBCA) 创建的数据库将启用使用可选管理包所需的 AWR、ADDM 和 PL/SQL 程序包。  对于低于 Oracle 11gR2 的版本，DBA 必须手动禁用这些可选功能，有多种方法可完成此操作。  此参数可简化该流程。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="51">使用数据库存储审计数据时，DBA 将移动 SYSTEM 表空间中的所有审计表。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="86">在过去，此审计表序列的缓存设置太小，不足以支持高并发登录率。  常见建议是将该值增加至不低于 1000。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="45">在尝试避免和/或调试各种问题时，了解哪些数据库链接处于非活动状态或无法访问非常有用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="43">Oracle 建议至少有三个重做日志组且每个组有两个成员以实现冗余（且因此实现可用性）。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="85">AWR 快照将消耗资源，因此不要过于频繁地计划该快照。  另外，默认保留期对于有效使用而言太短，因此应增加此值。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="126">许多应用程序在典型会话期间将调用相同的 SQL 语句，因此缓存至少 20 个游标可能会减少 Parse Call 和游标 OPEN。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="122">您必须将 OPEN_CURSORS 的值设置为足够大，以防止应用程序耗尽打开游标数。  该数目将根据应用程序的不同而有所不同。  假设会话未打开 OPEN_CURSORS 指定的游标数，则将此值设置高于实际所需值不会增加开销。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="125">REMOTE_LOGIN_PASSWORDFILE 指定 Oracle 是否检查密码文件。  如果设置为 NONE，则 Oracle 将忽略任何密码文件，因此特权用户必须通过操作系统进行身份验证。  向后兼容性支持 EXCLUSIVE。  目前，此值与值 SHARED 具有相同的行为。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="120">如果未特别设置重做日志检查点超时，则建议使用顾问实用程序，该实用程序可让您指定恢复 (MTTR) 恢复间隔的最佳平均时间，以便可以建议最佳重做日志大小。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="155">PLSQL_OPTIMIZE_LEVEL 将指定用于编译 PL/SQL 库单元的优化水平。  此参数的设置越高，编译器便会越有效地优化 PL/SQL 库单元。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="156">PLSQL_CODE_TYPE 将指定 PL/SQL 库单元的的编译模式。  NATIVE 表示 PL/SQL 库单元（可能的例外是顶层匿名 PL/SQL 块）将编译为本机（机器）代码。  此类模块将在本机执行，不会产生任何解释器开销。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="158">PLSQL_COMPILER_FLAGS 将 PL/SQL 编译器的标记列表指定为逗号分隔的字符串列表。  NATIVE 表示 PL/SQL 库单元（可能的例外是顶层匿名 PL/SQL 块）将编译为本机（机器）代码。  此类模块将在本机执行，不会产生任何解释器开销。  NON_DEBUG 表示将编译 PL/SQL 库单元以便正常执行。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="57">关系数据库表通常具有至少一个唯一键和/或索引，以便可以将一行与另一个区分开来。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="9">索引将增加所有 INSERT、UPDATE 和 DELETE 命令的开销。  因此，您应将任何指定表的索引数量最大限度地减少到实际所需的数量，以确保数据准确性和/或查询性能。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="46">ORA-0600 错误是一般常见错误，由于这些错误较新，尚未拥有其自身的分配编号。  在大多数情况下，ORA-0600 错误需要致电 Oracle 技术支持部门，因为这通常是数据库存在问题或错误。  在大多数情况下，导致错误的应用程序仅会暴露 Oracle 问题。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="59">关系数据库表通常又窄又长。  这意味着表的列很少，但行很多。  设计理念是利用标准化技术确保所有表设计合理。  数据仓库是个例外，其中维度表通常较宽（即有许多列）。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="60">索引将增加所有 INSERT、UPDATE 和 DELETE 命令的开销。  因此，您应将任何指定表的索引大小（即列数）最大限度地减少到实际所需的列数，以确保数据准确性和/或查询性能。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="61">LOG 和 RAW 数据类型已替换为 CLOB 和 BLOB 数据类型。  Oracle 建议不再使用旧数据类型。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="62">知道您何时具有全局索引（即分区策略与表的分区策略不匹配的索引）可能非常有用。  有时全局索引更合适。  但一般情况下，本地索引（即分区策略与表的分区策略匹配的索引）是标准设置。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="63">如果表的行大小大于数据库或表空间的块大小，则每行需要两个 IO。  您可能需要增加数据库块大小（执行重组）或将该表移到具有较大块大小的表空间（重定位）。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="54">考虑到索引的 INSERT、UPDATE 和 DELETE 开销成本，您需要设计所有索引，且不存在重叠索引或重复效果。  优化器在给定条件下只能使用一个索引，因此设计索引以便可以应对各种情况。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="58">尽管更新版本的 Oracle 可以维护使用非唯一索引的主键和唯一键约束，但 DBA 可能想要了解这些约束。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="31">如果联接父表（使用主键）和子表（使用外键），则在数据类型或长度不相同时，性能将会下降。  尽管它本质上是允许主键和外键不匹配的关系设计错误，但仍会正常运行。  但是，优化器将需要向解释计划添加步骤以执行隐式数据类型转换，这意味着索引可能无法使用。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="53">如果子表在外键中没有索引，则该子表中的特定 DML 操作将需要锁住父表中的某个级别，从而可能从根本上降低性能。  有关完整说明，请参阅 Oracle 概念手册： “数据完整性”一章“并发控制、索引和外键”一节。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="64">与大众的想法正相反，没有所谓的部分外键。  根据定义，子表的外键必须指向父表中存在的一行或为 null。  这意味着整个外键，而不仅仅是部分外键。  如果创建包含强制列和可选列的外键，则在一些列存在而另一些列为 null 时，数据库不会强制执行该约束。  有关完整说明，请参阅 Oracle 概念手册： “数据完整性”一章“Null 和外键”一节。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="65">根据定义，唯一键应是未选择作为主键的候选主键。  由于主键不允许存在可选列，也不会选择候选唯一键作为主键。  有关完整说明，请参阅 Oracle 概念手册： “数据完整性”一章“组合唯一键和非 NULL 完整性约束”一节。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="38">如果使用混合大小写和/或空格定义表和/或列，则应用程序中这些项目的所有引用必须用引号引起这些引用。  此任务非常繁琐，因此通常会避免使用。  唯一的例外是以此方式构建的第三方应用程序和/或从其他平台移动的数据库（如 MS SQL Server），其中混合大小写名称更常见。  在这些情况下，您可能难以摆脱混合大小写。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="160">CLIENT_RESULT_CACHE_LAG 将指定自上次往返服务器以来的最大时间（毫秒），在此之前，OCI 客户端查询执行将往返服务器以获取与客户端中缓存的查询相关的任何数据库更改。  如果将此值设置太高，可能会导致使用陈旧数据。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="161">CLIENT_RESULT_CACHE_SIZE 将指定客户端每个进程结果集缓存的最大大小（字节）。  所有 OCI 客户端进程将继承其最大大小。  设置非零值将启用客户端查询缓存功能。  此值可能会被客户端配置参数 OCI_RESULT_CACHE_MAX_SIZE 覆盖。  目前大多数客户端机器上的内存价廉易得，因此将缓存设置为至少 4 MB。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="162">DB_ULTRA_SAFE 将设置控制保护级别的其他参数的默认值。  保得安全总比后悔好 - 请勿设置为 OFF。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="164">JAVA_JIT_ENABLED 将启用或禁用 Oracle Java Virtual Machine (OracleJVM) 环境的即时 (Just-In-Time, JIT) 编译器。  大多数应用程序开发人员更喜欢在数据库之外使用 JVM，因此通常无需使用 Oracle JVM。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="165">JAVA_POOL_SIZE 将指定 Java 池的大小（字节），Java 内存管理器可从 Java 池中在运行时执行期间分配大多数 Java 状态。  大多数应用程序开发人员更喜欢在数据库之外使用 JVM，因此通常无需使用 Oracle JVM。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="166">Java 会话空间是从一个数据库调用到另一个数据库调用时保存 Java 状态的内存。  大多数应用程序开发人员更喜欢在数据库之外使用 JVM，因此通常无需使用 Oracle JVM。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="168">OPTIMIZER_USE_INVISIBLE_INDEXES 可启用或禁用使用不可见索引。  FALSE 表示优化器不考虑但 DML 操作仍会维护不可见索引。  如果索引确实不可见，则优化器通常不会考虑这些索引。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="169">禁用此参数，除非您特别想要利用回收站，否则删除的对象仍会占用空间，除非在 DROP 命令中已指定 PURGE 选项。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="170">RESULT_CACHE_MAX_RESULT 将指定任何单个结果可使用的 RESULT_CACHE_MAX_SIZE 的百分比。  如果使用此功能，建议不要将其设置为低于默认值的值。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="171">RESULT_CACHE_MODE 将指定 ResultCache 运算符拼接到查询执行计划中的时间。  FORCE 表示 ResultCache 运算符将添加到所有 SELECT 语句的根（前提是执行此操作有效）。  这可能是太宽的设置，在有意义的这些情况下，可能最好使用提示。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="172">RESULT_CACHE_REMOTE_EXPIRATION 将指定允许使用远程对象的结果保持有效的分钟数。  将此参数设置为 0 则意味着不缓存使用远程对象的结果。  将此参数设置为非零值可能会产生陈旧的答案（例如，如果在远程数据库中已修改结果所使用的远程表）。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="143">Oracle 建议至少有三个重做日志组且每个组有两个成员以实现冗余（且因此实现可用性）。</Item>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="88"/>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="49"/>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="48"/>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="47"/>
	<Item lang_abbrev="CHS" culture_id="2052" culture_name="zh-CN" InternalID="5"/>
</HealthCheckItems>
